/*
crPoleZ:生成極軸Z
crPoleY:生成極軸Y
crPoleX:生成極軸X
compareRotateOrder:把rotationOrder字串轉成陣列
reOrderRotAxis:調整rotationRorder
crPole:生成極作標輔助器
*/

/*
//ex:產生座標
$sels=`ls- sl`;
for ($obj in $sels){
	crPole($obj,1);
	}
*/


proc string crPoleZ(string $nm,float $scale){
    curve -d 1 -p 0 0 0 -p 0 0 1.5 -p -0.1 0 1.4 -p 0 0 1.7 -p 0.1 0 1.4 -k 0 -k 1 -k 2 -k 3 -k 4 ;
    rename $nm;
    scale $scale $scale $scale;
    rotate 0 0 90;
    makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;
    setAttr ($nm+".overrideEnabled") 1;
    setAttr ($nm+".overrideColor") 6;
    return $nm;
    } 

proc string crPoleY(string $nm,float $scale){
    curve -d 1 -p 0 0 0 -p 0 0 1.5 -p -0.1 0 1.4 -p 0 0 1.7 -p 0.1 0 1.4 -k 0 -k 1 -k 2 -k 3 -k 4 ;
    rename $nm;
    rotate -90 0 0;
    scale $scale $scale $scale;
    makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;
    setAttr ($nm+".overrideEnabled") 1;
    setAttr ($nm+".overrideColor") 14;
    return $nm;
    } 

proc string crPoleX(string $nm,float $scale){
    curve -d 1 -p 0 0 0 -p 0 0 1.5 -p -0.1 0 1.4 -p 0 0 1.7 -p 0.1 0 1.4 -k 0 -k 1 -k 2 -k 3 -k 4 ;
    rename $nm;
    rotate 0 90 0;
    scale $scale $scale $scale;
    makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;
    setAttr ($nm+".overrideEnabled") 1;
    setAttr ($nm+".overrideColor") 13;
    return $nm;
    } 
    
proc string[] compareRotateOrder(string $order){
    $axis={"X","Y","Z"};
    string $orders[];
    string $diff[];
    string $last[];    
    for($pole in $axis){
        if (`gmatch $order ($pole+"??")`){
            $orders[0]=$pole;          
            }
        if (`gmatch $order ("?"+$pole+"?")`){
            $orders[1]=$pole;          
            }
        if (`gmatch $order ("??"+$pole)`){
            $orders[2]=$pole;          
            }            
        }    

    return $orders;
    }
    
global  proc reOrderRotAxis(string $obj,string $nm){
    /*$ro:rotation order
    */
    string $orID[]={"XYZ","YZX","ZXY","XZY","YXZ","ZYX"};
    string $translation[]={"tx","ty","tz","rx","ry","rz"};    

    int $ro=`getAttr ($obj+".rotateOrder")`;    
    string $ors[]=compareRotateOrder($orID[$ro]);

    for ($attr in $translation){
        setAttr -lock off -keyable on -channelBox off ($nm+$ors[0]+"."+$attr);
        setAttr -lock off -keyable on -channelBox off ($nm+$ors[1]+"."+$attr);
        setAttr -lock off -keyable on -channelBox off ($nm+$ors[2]+"."+$attr);
        }
        
    parent  -w ($nm+$ors[0]) ($nm+$ors[1]) ($nm+$ors[2]);
    setAttr ($nm+".rotateOrder") $ro;
    scale 1 1 1 ($nm+$ors[0]) ($nm+$ors[1]) ($nm+$ors[2]);
    
    scale 0.3 0.3 0.3 ($nm+$ors[0]);
    scale 0.6 0.6 0.6 ($nm+$ors[1]);    
    parent ($nm+$ors[0]) ($nm+$ors[1]);
    parent ($nm+$ors[1]) ($nm+$ors[2]);
    parent ($nm+$ors[2]) $nm;
    for ($attr in $translation){
        setAttr -lock true -keyable false -channelBox false ($nm+$ors[0]+"."+$attr);
        setAttr -lock true -keyable false -channelBox false ($nm+$ors[1]+"."+$attr);
        setAttr -lock true -keyable false -channelBox false ($nm+$ors[2]+"."+$attr);
        }
    }
    

global proc crPole(string $nm,float $scale){
  
    $vct=`group -em -n ($nm+"_vct")`;

    $poleZ=crPoleZ(($nm+"_vctZ"),$scale);
    $poleY=crPoleY(($nm+"_vctY"),$scale);
    $poleX=crPoleX(($nm+"_vctX"),$scale);
    parent $poleZ $poleY $poleX $vct;
    if (`objExists $nm`){  
        reOrderRotAxis($nm,$vct);
        $cons=`parentConstraint $nm $vct`;
        delete $cons;
        }
    }
